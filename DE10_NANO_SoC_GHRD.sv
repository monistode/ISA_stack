//=======================================================
//  This code *was, at some time, * generated by Terasic System Builder
//=======================================================

module DE10_NANO_SoC_GHRD(

    //////////// CLOCK //////////
    input logic              FPGA_CLK1_50,
    input logic              FPGA_CLK2_50,
    input logic              FPGA_CLK3_50,

    //////////// HPS //////////
    output logic  [14: 0]    HPS_DDR3_ADDR,
    output logic  [ 2: 0]    HPS_DDR3_BA,
    output logic             HPS_DDR3_CAS_N,
    output logic             HPS_DDR3_CK_N,
    output logic             HPS_DDR3_CK_P,
    output logic             HPS_DDR3_CKE,
    output logic             HPS_DDR3_CS_N,
    output logic  [ 3: 0]    HPS_DDR3_DM,
    inout  logic  [31: 0]    HPS_DDR3_DQ,
    inout  logic  [ 3: 0]    HPS_DDR3_DQS_N,
    inout  logic  [ 3: 0]    HPS_DDR3_DQS_P,
    output logic             HPS_DDR3_ODT,
    output logic             HPS_DDR3_RAS_N,
    output logic             HPS_DDR3_RESET_N,
    input  logic             HPS_DDR3_RZQ,
    output logic             HPS_DDR3_WE_N,

    //////////// LED //////////
    output logic  [ 7: 0]    LED,

    //////////// SWITCHES //////////
    input  logic  [ 3: 0]    SW,
     
     //////////// SWITCHES //////////
     input  logic  [ 1: 0]    KEY
);

//=======================================================
//  reg/wire declarations
//=======================================================
logic hps_fpga_reset_n;
logic fpga_clk_50;

logic [15:0] address = 16'd0;
logic read = 1'b0;
logic write = 1'b0;
logic acknowledge;
logic [31:0] read_data = 32'd0;
logic [31:0] write_data = 32'd0;
logic [3:0] byte_enable = 4'b1111;

// connection of internal logics
assign fpga_clk_50 = FPGA_CLK1_50;

//=======================================================
//  Structural coding
//=======================================================
soc_system u_u0(
    //Clock&Resetread_data[6:0]
    .clk_clk(FPGA_CLK1_50),                                      //                            clk.clk
    .reset_reset_n(hps_fpga_reset_n),                            //                          reset.reset_n
    //HPS ddr3
    .memory_mem_a(HPS_DDR3_ADDR),                                //                         memory.mem_a
    .memory_mem_ba(HPS_DDR3_BA),                                 //                               .mem_ba
    .memory_mem_ck(HPS_DDR3_CK_P),                               //                               .mem_ck
    .memory_mem_ck_n(HPS_DDR3_CK_N),                             //                               .mem_ck_n
    .memory_mem_cke(HPS_DDR3_CKE),                               //                               .mem_cke
    .memory_mem_cs_n(HPS_DDR3_CS_N),                             //                               .mem_cs_n
    .memory_mem_ras_n(HPS_DDR3_RAS_N),                           //                               .mem_ras_n
    .memory_mem_cas_n(HPS_DDR3_CAS_N),                           //                               .mem_cas_n
    .memory_mem_we_n(HPS_DDR3_WE_N),                             //                               .mem_we_n
    .memory_mem_reset_n(HPS_DDR3_RESET_N),                       //                               .mem_reset_n
    .memory_mem_dq(HPS_DDR3_DQ),                                 //                               .mem_dq
    .memory_mem_dqs(HPS_DDR3_DQS_P),                             //                               .mem_dqs
    .memory_mem_dqs_n(HPS_DDR3_DQS_N),                           //                               .mem_dqs_n
    .memory_mem_odt(HPS_DDR3_ODT),                               //                               .mem_odt
    .memory_mem_dm(HPS_DDR3_DM),                                 //                               .mem_dm
    .memory_oct_rzqin(HPS_DDR3_RZQ),                             //                               .oct_rzqin

    .hps_0_h2f_reset_reset_n(hps_fpga_reset_n),                  //                hps_0_h2f_reset.reset_n
    .sdram_address(address),
    .sdram_byte_enable(byte_enable),                             //                .byte_enable
    .sdram_read(read),              //                .read
    .sdram_write(write),             //                .write
    .sdram_write_data(write_data),        //                .write_data
    .sdram_acknowledge(acknowledge),       //                .acknowledge
    .sdram_read_data(read_data)
);

//=======================================================
//  Memory read/write finite automata
//=======================================================

enum int unsigned {
    MEM_STATE_INIT = 1,
    MEM_STATE_READ_PENDING = 2,
    MEM_STATE_WRITE_PENDING = 3
} cur_mem_state, next_mem_state;

logic read_req  = 0;
logic write_req = 0;

// State switch logic
always_comb begin
    next_mem_state = cur_mem_state;
    case (cur_mem_state)
        MEM_STATE_INIT: begin
            if (read_req) next_mem_state = MEM_STATE_READ_PENDING;
            else if (write_req) next_mem_state = MEM_STATE_WRITE_PENDING;
        end

        MEM_STATE_READ_PENDING: begin
            if (acknowledge) next_mem_state = MEM_STATE_INIT;
        end

        MEM_STATE_WRITE_PENDING: begin
            if (acknowledge) next_mem_state = MEM_STATE_INIT;
        end

        default: begin
            next_mem_state = MEM_STATE_INIT;
        end
    endcase
end

always_comb begin
    read = 0;
    write = 0;

    case (cur_mem_state)
        MEM_STATE_READ_PENDING: begin
            read = 1;
        end

        MEM_STATE_WRITE_PENDING: begin
            write = 1;
        end

        default: begin
        end
    endcase
end

//=======================================================
//  CPU state enum and regs / wires
//=======================================================

logic fetch_done    = 0;
logic decode_done   = 0;
logic op_fetch_done = 0;
logic exec_done     = 0;
logic write_done    = 0;

enum int unsigned {
    CPU_STATE_INSTR_FETCH         = 1,
    CPU_STATE_INSTR_DECODE        = 2,
    CPU_STATE_INSTR_OPERAND_FETCH = 3,
    CPU_STATE_INSTR_EXEC          = 4,
    CPU_STATE_INSTR_WRITEBACK     = 5
} cur_cpu_state, next_cpu_state;

// State switch logic
always_comb begin
    next_cpu_state = cur_cpu_state;
    case (cur_cpu_state)
        CPU_STATE_INSTR_FETCH: begin
            if (fetch_done) next_cpu_state = CPU_STATE_INSTR_DECODE;
        end

        CPU_STATE_INSTR_DECODE: begin
            if (decode_done) next_cpu_state = CPU_STATE_INSTR_OPERAND_FETCH;
        end

        CPU_STATE_INSTR_OPERAND_FETCH: begin
            if (op_fetch_done) next_cpu_state = CPU_STATE_INSTR_EXEC;
        end

        CPU_STATE_INSTR_EXEC: begin
            if (exec_done) next_cpu_state = CPU_STATE_INSTR_WRITEBACK;
        end

        CPU_STATE_INSTR_WRITEBACK: begin
            if (write_done) next_cpu_state = CPU_STATE_INSTR_FETCH;
        end

        default: begin
            next_cpu_state = CPU_STATE_INSTR_FETCH;
        end
    endcase
end

//=======================================================
//  CPU single-step button setup.
//=======================================================

// Cpu single-step clock setup
// If a SW[3] is set to 1,
// then the cpu cycles by pressing KEY[1]
logic [1:0] debounced_keys = 2'd0;
debounce #(2, "LOW", 50000, 16) debouncer(
    .clk(fpga_clk_50),
    .reset_n(hps_fpga_reset_n),
    .data_in(KEY),
    .data_out(debounced_keys)
);

reg   is_halted    = 0;
reg   cycle_done   = 1;
reg   prev_pressed = 0;

//=======================================================
//  CPU instruction decoder / registers
//=======================================================

parameter MEM_STACK_BASE = 16'd256;
parameter REG_STACK_BASE = 16'd1024;
parameter STATIC_ARGS_BASE = 16'd1536;

reg [5:0]  cur_instruction = 6'd0;
reg [15:0] PC = 0;
reg [15:0] FR = 16'd0;
reg [15:0] TOS           = MEM_STACK_BASE;
reg [15:0] SP            = REG_STACK_BASE;

// CPU variables
reg [31:0] data = 31'd0;
assign LED[7: 0] = data[7: 0];

always_ff @(posedge fpga_clk_50 or negedge hps_fpga_reset_n) begin
    if (~hps_fpga_reset_n) begin
        cur_mem_state <= MEM_STATE_INIT;
        cur_cpu_state <= CPU_STATE_INSTR_FETCH;
        read_req <= '0;
        write_req <= '0;
        prev_pressed <= debounced_keys[1];
        cycle_done <= 1;

        cur_instruction <= 6'd0;
        PC <= 0;
        FR <= 16'd0;
        TOS <= MEM_STACK_BASE;
        SP <= REG_STACK_BASE;
    end else begin
        // Lotsa logic, sorry
        cur_mem_state <= next_mem_state;
        cur_cpu_state <= next_cpu_state;

        if (~debounced_keys[0]) is_halted <= 0;

        prev_pressed <= debounced_keys[1];
        case (cur_mem_state)
            MEM_STATE_INIT: begin
            end

            MEM_STATE_READ_PENDING: begin
                if (acknowledge) data <= read_data;
                read_req <= 0;
                write_req <= 0;
            end

            MEM_STATE_WRITE_PENDING: begin
                read_req <= 0;
                write_req <= 0;
            end

            default: begin
                read_req <= 0;
                write_req <= 0;
            end
        endcase

        //=======================================================
        //  The instruction decoder itself. Finally )
        //=======================================================
        if (cur_mem_state == MEM_STATE_INIT & ~is_halted &
            (~SW[3] | (prev_pressed & ~debounced_keys[1] & cycle_done) | ~cycle_done)) begin

            if (cur_cpu_state == CPU_STATE_INSTR_FETCH) begin
                // 4 CPU instrictuions fit into 4 bytes, could be 5, but naaah
                byte_enable <= 4'b1111;
                address <= REG_STACK_BASE + PC[15:2];
                read_req <= 1;
                PC <= PC + '1;
                cycle_done <= '0;

                fetch_done    <= '1;
                decode_done   <= '0;
                op_fetch_done <= '0;
                exec_done     <= '0;
                write_done    <= '0;
            end else if (cur_cpu_state == CPU_STATE_INSTR_DECODE) begin
                cur_instruction <= data[PC[1:0] * 8 + 5 -: 6];
                fetch_done    <= '0;
                decode_done   <= '1;
                op_fetch_done <= '0;
                exec_done     <= '0;
                write_done    <= '0;
            end else begin
                case (cur_instruction)
                    // HALT
                    6'b000000: begin
                        case (cur_cpu_state)
                            CPU_STATE_INSTR_OPERAND_FETCH: begin
                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '1;
                                exec_done     <= '0;
                                write_done    <= '0;
                            end

                            CPU_STATE_INSTR_EXEC: begin
                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '0;
                                exec_done     <= '1;
                                write_done    <= '0;
                            end

                            CPU_STATE_INSTR_WRITEBACK: begin
                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '0;
                                exec_done     <= '1;
                                write_done    <= '1;

                                is_halted <= '1;
                                cycle_done <= '1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    // LOAD
                    6'b000001: begin
                        case (cur_cpu_state)
                            CPU_STATE_INSTR_OPERAND_FETCH: begin
                                byte_enable <= 4'b1111;
                                address <= {SP[15:2], 2'b00};
                                read_req <= 1;

                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '1;
                                exec_done     <= '0;
                                write_done    <= '0;
                            end

                            CPU_STATE_INSTR_EXEC: begin
                                if (SP[1]) begin
                                    byte_enable <= 4'b1100;
                                    write_data[31:16] <= data[31:16];
                                    address <= {SP[15:2], 2'b00};
                                end else begin
                                    byte_enable <= 4'b0011;
                                    write_data[15:0] <= data[15:0];
                                    address <= {SP[15:2], 2'b00};
                                end

                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '0;
                                exec_done     <= '1;
                                write_done    <= '0;
                            end

                            CPU_STATE_INSTR_WRITEBACK: begin
                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '0;
                                exec_done     <= '1;
                                write_done    <= '1;
                                cycle_done <= '1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    // LOAD %FR
                    6'b000010: begin
                        case (cur_cpu_state)
                            CPU_STATE_INSTR_OPERAND_FETCH: begin
                                SP <= SP + 16'd2;
                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '1;
                                exec_done     <= '0;
                                write_done    <= '0;
                            end

                            CPU_STATE_INSTR_EXEC: begin
                                if (SP[1]) begin
                                    byte_enable <= 4'b1100;
                                    write_data[31:16] <= FR;
                                    address <= {SP[15:2], 2'b00};
                                end else begin
                                    byte_enable <= 4'b0011;
                                    write_data[15:0] <= FR;
                                    address <= {SP[15:2], 2'b00};
                                end

                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '0;
                                exec_done     <= '1;
                                write_done    <= '0;
                            end

                            CPU_STATE_INSTR_WRITEBACK: begin
                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '0;
                                exec_done     <= '1;
                                write_done    <= '1;
                                cycle_done <= '1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    // LOAD %FR
                    6'b000010: begin
                        case (cur_cpu_state)
                            CPU_STATE_INSTR_OPERAND_FETCH: begin
                                address <= STATIC_ARGS_BASE + PC[15:2];
                                byte_enable <= 4'b1111;

                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '1;
                                exec_done     <= '0;
                                write_done    <= '0;
                            end

                            CPU_STATE_INSTR_EXEC: begin
                                SP <= SP + 16'd2;

                                read_req <= 1;
                                byte_enable <= 4'b1111;
                                address <= data[PC[1] * 16 + 15 -: 16];

                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '0;
                                exec_done     <= '1;
                                write_done    <= '0;
                            end

                            CPU_STATE_INSTR_WRITEBACK: begin
                                if (SP[1]) begin
                                    byte_enable <= 4'b1100;
                                    write_data[31:16] <= data[address[1] * 16 + 15 -: 16];
                                end else begin
                                    byte_enable <= 4'b0011;
                                    write_data[15:0] <= data[address[1] * 16 + 15 -: 16];
                                end

                                fetch_done    <= '0;
                                decode_done   <= '0;
                                op_fetch_done <= '0;
                                exec_done     <= '1;
                                write_done    <= '1;
                                cycle_done <= '1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end
        end
    end
end

endmodule
