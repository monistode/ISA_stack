                                        //=======================================================
//  This code *was, at some time, * generated by Terasic System Builder
//=======================================================

module DE10_NANO_SoC_GHRD(

    //////////// CLOCK //////////
    input logic              FPGA_CLK1_50,
    input logic              FPGA_CLK2_50,
    input logic              FPGA_CLK3_50,

    //////////// HPS //////////
    output logic  [14: 0]    HPS_DDR3_ADDR,
    output logic  [ 2: 0]    HPS_DDR3_BA,
    output logic             HPS_DDR3_CAS_N,
    output logic             HPS_DDR3_CK_N,
    output logic             HPS_DDR3_CK_P,
    output logic             HPS_DDR3_CKE,
    output logic             HPS_DDR3_CS_N,
    output logic  [ 3: 0]    HPS_DDR3_DM,
    inout  logic  [31: 0]    HPS_DDR3_DQ,
    inout  logic  [ 3: 0]    HPS_DDR3_DQS_N,
    inout  logic  [ 3: 0]    HPS_DDR3_DQS_P,
    output logic             HPS_DDR3_ODT,
    output logic             HPS_DDR3_RAS_N,
    output logic             HPS_DDR3_RESET_N,
    input  logic             HPS_DDR3_RZQ,
    output logic             HPS_DDR3_WE_N,

    //////////// GPIO //////////
    inout  logic  [35:0]     GPIO_D,

    //////////// LED //////////
    output logic  [ 7: 0]    LED,

    //////////// SWITCHES //////////
    input  logic  [ 3: 0]    SW,
     
    //////////// SWITCHES //////////
    input  logic  [ 1: 0]    KEY
);

//=======================================================
//  reg/wire declarations
//=======================================================
logic hps_fpga_reset_n;
logic fpga_clk_50;

//=======================================================
//  RAM variables
//=======================================================
logic [21:0] address = 16'd0;
logic read = 1'b0;
logic write = 1'b0;
logic acknowledge;
logic [31:0] read_data = 32'd0;
logic [31:0] write_data = 32'd0;
logic [3:0] byte_enable = 4'b1111;

//=======================================================
//  UART variables
//=======================================================
logic [7:0] uart_wdata;
logic uart_write;
logic uart_in_error;
logic uart_in_ready;

logic [7:0] uart_rdata;
logic uart_out_ready;
logic uart_out_error;
logic uart_out_valid;
logic [31:0] GPIOS;

// connection of internal logics
assign fpga_clk_50 = FPGA_CLK1_50;
assign GPIO_D[34:3] = GPIOS;

//=======================================================
//  Structural coding
//=======================================================
soc_system u_u0(
    //Clock&Resetread_data[6:0]
    .clk_clk(FPGA_CLK1_50),                                      //                            clk.clk
    .reset_reset_n(hps_fpga_reset_n),                            //                          reset.reset_n
    //HPS ddr3
    .memory_mem_a(HPS_DDR3_ADDR),                                //                         memory.mem_a
    .memory_mem_ba(HPS_DDR3_BA),                                 //                               .mem_ba
    .memory_mem_ck(HPS_DDR3_CK_P),                               //                               .mem_ck
    .memory_mem_ck_n(HPS_DDR3_CK_N),                             //                               .mem_ck_n
    .memory_mem_cke(HPS_DDR3_CKE),                               //                               .mem_cke
    .memory_mem_cs_n(HPS_DDR3_CS_N),                             //                               .mem_cs_n
    .memory_mem_ras_n(HPS_DDR3_RAS_N),                           //                               .mem_ras_n
    .memory_mem_cas_n(HPS_DDR3_CAS_N),                           //                               .mem_cas_n
    .memory_mem_we_n(HPS_DDR3_WE_N),                             //                               .mem_we_n
    .memory_mem_reset_n(HPS_DDR3_RESET_N),                       //                               .mem_reset_n
    .memory_mem_dq(HPS_DDR3_DQ),                                 //                               .mem_dq
    .memory_mem_dqs(HPS_DDR3_DQS_P),                             //                               .mem_dqs
    .memory_mem_dqs_n(HPS_DDR3_DQS_N),                           //                               .mem_dqs_n
    .memory_mem_odt(HPS_DDR3_ODT),                               //                               .mem_odt
    .memory_mem_dm(HPS_DDR3_DM),                                 //                               .mem_dm
    .memory_oct_rzqin(HPS_DDR3_RZQ),                             //                               .oct_rzqin

    .hps_0_h2f_reset_reset_n(hps_fpga_reset_n),                  //                hps_0_h2f_reset.reset_n
    .sdram_address(address),
    .sdram_byte_enable(byte_enable),                             //                .byte_enable
    .sdram_read(read),              //                .read
    .sdram_write(write),             //                .write
    .sdram_write_data(write_data),        //                .write_data
    .sdram_acknowledge(acknowledge),       //                .acknowledge
    .sdram_read_data(read_data),

    .uart_RXD(GPIO_D[0]), // uart_0_external_connection.rxd
    .uart_TXD(GPIO_D[1]), //                           .txd

    .uart_in_data(uart_wdata),
    .uart_in_error(uart_in_error),
    .uart_in_valid(uart_write),
    .uart_in_ready(uart_in_ready),

    .uart_out_ready(uart_out_ready),
    .uart_out_data(uart_rdata),
    .uart_out_error(uart_out_error),
    .uart_out_valid(uart_out_valid)
);

//=======================================================
//  Memory read/write finite automata
//=======================================================

enum int unsigned {
    MEM_STATE_INIT = 1,
    MEM_STATE_READ_PENDING = 2,
    MEM_STATE_WRITE_PENDING = 3
} cur_mem_state, next_mem_state;

logic read_req  = 0;
logic write_req = 0;

// State switch logic
always_comb begin
    next_mem_state = cur_mem_state;
    case (cur_mem_state)
        MEM_STATE_INIT: begin
            if (read_req) next_mem_state = MEM_STATE_READ_PENDING;
            else if (write_req) next_mem_state = MEM_STATE_WRITE_PENDING;
        end

        MEM_STATE_READ_PENDING: begin
            if (acknowledge) next_mem_state = MEM_STATE_INIT;
        end

        MEM_STATE_WRITE_PENDING: begin
            if (acknowledge) next_mem_state = MEM_STATE_INIT;
        end

        default: begin
            next_mem_state = MEM_STATE_INIT;
        end
    endcase
end

always_comb begin
    read = 0;
    write = 0;

    case (cur_mem_state)
        MEM_STATE_READ_PENDING: begin
            read = 1;
        end

        MEM_STATE_WRITE_PENDING: begin
            write = 1;
        end

        default: begin
        end
    endcase
end

//=======================================================
//  CPU state enum and regs / wires
//=======================================================
enum int unsigned {
    CPU_STATE_INSTR_FETCH           = 1,
    CPU_STATE_INSTR_DECODE          = 2,
    CPU_STATE_INSTR_IMM_FETCH       = 3,
    CPU_STATE_INSTR_IMM_FETCH_1     = 4,
    CPU_STATE_INSTR_OPERAND_FETCH   = 5,
    CPU_STATE_INSTR_OPERAND_FETCH_1 = 6,
    CPU_STATE_INSTR_EXEC            = 7,
    CPU_STATE_INSTR_EXEC_1          = 8,
    CPU_STATE_INSTR_WRITEBACK       = 9,
    CPU_STATE_INSTR_WRITEBACK_1     = 10
} cur_cpu_state;

//=======================================================
//  CPU single-step button setup.
//=======================================================

// Cpu single-step clock setup
// If a SW[3] is set to 1,
// then the cpu cycles by pressing KEY[1]
logic [1:0] debounced_keys = 2'd0;
debounce #(2, "LOW", 50000, 16) debouncer(
    .clk(fpga_clk_50),
    .reset_n(hps_fpga_reset_n),
    .data_in(KEY),
    .data_out(debounced_keys)
);

reg   is_halted    = 0;
reg   cycle_done   = 1;
reg   prev_pressed = 0;

//=======================================================
//  CPU instruction decoder / registers
//=======================================================

parameter MEM_STACK_BASE = 16'hFE;
parameter REG_STACK_BASE = 16'h400;
parameter MEM_BASE = 16'h10000;

reg [5:0]  cur_instruction = 6'd0;
reg [15:0] PC = 16'd0;
reg [15:0] IMM_ADDR = 16'd0;
reg [15:0] FR = 16'd0;
reg [15:0] TOS = MEM_STACK_BASE;
reg [15:0] SP  = REG_STACK_BASE;

// CPU variables
reg [31:0] data = 32'd0;
reg [15:0] tmp_address = 16'd0;
reg [15:0] tmp_word = 16'd0;
reg [15:0] cur_imm = 16'd0;
assign LED[7: 0] = PC[7:0];

//=======================================================
//  UART I/O variables and logic
//=======================================================
logic uart_write_req = 0;
logic uart_read_req = 0;
logic [7:0] uart_data = 0;

always_ff @(posedge fpga_clk_50 or negedge hps_fpga_reset_n) begin
if (~hps_fpga_reset_n) begin


cur_mem_state <= MEM_STATE_INIT;
cur_cpu_state <= CPU_STATE_INSTR_FETCH;
cycle_done <= 1;

read_req <= '0;
write_req <= '0;
prev_pressed <= debounced_keys[1];

cur_instruction <= 6'd0;
PC <= 0;
FR <= 16'd0;
TOS <= MEM_STACK_BASE;
SP <= REG_STACK_BASE;
uart_out_ready <= '1;
uart_write <= 0;


end else begin


if (uart_out_valid) begin
    uart_data <= uart_rdata;
    uart_read_req <= 0;
    uart_out_ready <= 0;
    uart_write <= 0;
end

if (uart_write) begin
    uart_write_req <= 0;
    uart_out_ready <= 0;
    uart_write <= 0;
end

if (uart_write_req & uart_in_ready & ~uart_out_valid & ~uart_write) begin
    uart_out_ready <= 0;
    uart_write <= 1;
end else if (uart_read_req & ~uart_out_valid) begin
    uart_out_ready <= 1;
    uart_write <= 0;
end 

// Lotsa logic, sorry
cur_mem_state <= next_mem_state;

if (~debounced_keys[0]) is_halted <= 0;
if (~debounced_keys[0] & SW[1]) begin
    SP <= REG_STACK_BASE;
    TOS <= MEM_STACK_BASE;
    PC <= 0;
end

prev_pressed <= debounced_keys[1];
case (cur_mem_state)
    MEM_STATE_INIT: begin
    end

    MEM_STATE_READ_PENDING: begin
        if (acknowledge) data <= read_data;
        read_req <= 0;
        write_req <= 0;
    end

    MEM_STATE_WRITE_PENDING: begin
        read_req <= 0;
        write_req <= 0;
    end

    default: begin
        read_req <= 0;
        write_req <= 0;
    end
endcase

//=======================================================
//  The instruction decoder itself. Finally )
//=======================================================
if (
    ~SW[1] & // If SW[1] is on, we wait for button 0 to set PC to 0
    cur_mem_state == MEM_STATE_INIT & ~is_halted & // Only do cpu stuff when memory is not read/written to
    ~read_req & ~write_req & // Same as line one
    ~uart_write_req &  ~uart_read_req &// Can't do UART either (
    (~SW[3] | (prev_pressed & ~debounced_keys[1] & cycle_done) | ~cycle_done) // Button checker
    ) begin
cycle_done <= cur_cpu_state == CPU_STATE_INSTR_WRITEBACK_1;

    case (cur_cpu_state)
        CPU_STATE_INSTR_FETCH: begin
            cur_cpu_state <= CPU_STATE_INSTR_DECODE;
        end

        CPU_STATE_INSTR_DECODE: begin
            cur_cpu_state <= CPU_STATE_INSTR_IMM_FETCH;
        end

        CPU_STATE_INSTR_IMM_FETCH: begin
            cur_cpu_state <= CPU_STATE_INSTR_IMM_FETCH_1;
        end

        CPU_STATE_INSTR_IMM_FETCH_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_OPERAND_FETCH;
        end

        CPU_STATE_INSTR_OPERAND_FETCH: begin
            cur_cpu_state <= CPU_STATE_INSTR_OPERAND_FETCH_1;
        end

        CPU_STATE_INSTR_OPERAND_FETCH_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_EXEC;
        end

        CPU_STATE_INSTR_EXEC: begin
            cur_cpu_state <= CPU_STATE_INSTR_EXEC_1;
        end

        CPU_STATE_INSTR_EXEC_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_WRITEBACK;
        end

        CPU_STATE_INSTR_WRITEBACK: begin
            cur_cpu_state <= CPU_STATE_INSTR_WRITEBACK_1;
        end

        CPU_STATE_INSTR_WRITEBACK_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_FETCH;
        end

        default: begin
            cur_cpu_state <= CPU_STATE_INSTR_FETCH;
        end
    endcase

    if (cur_cpu_state == CPU_STATE_INSTR_FETCH) begin
        // 4 CPU instrictuions fit into 4 bytes, could be 5, but naaah
        byte_enable <= 4'b1111;
        address <= {PC[15:2], 2'b00};
        IMM_ADDR <= PC + 16'd1;
        PC <= PC + 16'd1;
        read_req <= 1;
    end else if (cur_cpu_state == CPU_STATE_INSTR_DECODE) begin
        case (PC[1:0])
            2'b00: begin
                cur_instruction <= data[29:24];
                if (data[29]) begin
                    PC <= PC + 16'd3;
                    address <= {IMM_ADDR[15:2] , 2'b00};
                    read_req <= '1;
                    byte_enable <= 4'b1111;
                end
            end
            2'b01: begin
                cur_instruction <= data[5:0];
                if (data[5]) begin
                    PC <= PC + 16'd3;
                    address <= {IMM_ADDR[15:2] , 2'b00};
                    read_req <= '1;
                    byte_enable <= 4'b1111;
                end
            end
            2'b10: begin 
                cur_instruction <= data[13:8];
                if (data[13]) begin
                    PC <= PC + 16'd3;
                    address <= {IMM_ADDR[15:2] , 2'b00};
                    read_req <= '1;
                    byte_enable <= 4'b1111;
                end
            end
            2'b11: begin
                cur_instruction <= data[21:16];
                if (data[21]) begin
                    PC <= PC + 16'd3;
                    address <= {IMM_ADDR[15:2] , 2'b00};
                    read_req <= '1;
                    byte_enable <= 4'b1111;
                end
            end
            default: begin
            end
        endcase
    end else if (cur_instruction[5] & cur_cpu_state == CPU_STATE_INSTR_IMM_FETCH) begin
        case (IMM_ADDR[1:0])
            2'b00: cur_imm <= {data[3:0], data[13:8], data[21:16]};
            2'b01: cur_imm <= {data[11:8], data[21:16], data[29:24]};
            2'b10: begin
                cur_imm[15:6] <= {data[19:16], data[29:24]};
                address <= {IMM_ADDR[15:2], 2'b00} + 16'd4;
                read_req <= '1;
                byte_enable <= 4'b1111;
            end
            2'b11: begin
                cur_imm[15:12] <= data[26:24];
                address <= {IMM_ADDR[15:2], 2'b00} + 16'd4;
                read_req <= '1;
                byte_enable <= 4'b1111;
            end
            default: begin
            end
        endcase
    end else if (cur_instruction[5] & cur_cpu_state == CPU_STATE_INSTR_IMM_FETCH_1) begin
        case (IMM_ADDR[1:0])
            2'b10: cur_imm[5:0] <= data[5:0];
            2'b11: cur_imm[11:0] <= {data[5:0], data[13:8]};
            default: begin
            end
        endcase
    end else begin
        case (cur_instruction)
        // NOP, lol
        default: begin
        end

        // HALT
        6'b000000: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_WRITEBACK: begin
                    is_halted <= '1;
                end

                default: begin
                end
            endcase
        end

        // Debug cmd
        6'b110000: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    byte_enable <= 4'b1111;
                    address <= 16'h200;
                    write_data <= {cur_imm, PC};
                    write_req <= 1;
                    byte_enable <= 4'b1111;
                end

                default: begin
                end
            endcase
        end

        // LOAD
        6'b000001: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    read_req <= 1;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_address <= data[31:16];
                    else tmp_address <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC: begin
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {tmp_address[15:2], 2'b00};
                    read_req <= 1;
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    case (tmp_address[1:0])
                        2'b00: tmp_word <= data[15:0];
                        2'b01: tmp_word <= data[23:8];
                        2'b10: tmp_word <= data[31:16];
                        2'b11: begin
                            tmp_word[7:0] <= data[31:24];
                            address <= MEM_BASE + {tmp_address[15:2], 2'b00} + 16'd4;
                            read_req <= '1;
                            byte_enable <= 4'b1111;
                        end
                        default: begin
                        end
                    endcase
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    if (tmp_address[1:0] == 2'b11) tmp_word[15:8] <= data[7:0];
                end

                CPU_STATE_INSTR_WRITEBACK_1: begin
                    write_data <= {2{tmp_word}};

                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;

                    address <= MEM_BASE + {SP[15:2], 2'b00};

                    write_req <= '1;
                end

                default: begin
                end
            endcase
        end

        // LOAD %FR
        6'b000010: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    SP <= SP - 16'd2;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_data <= {2{FR}};

                    write_req <= '1;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                end

                default: begin
                end
            endcase
        end

        // LOAD [mem]
        6'b100000: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    address <= MEM_BASE + {cur_imm[15:2], 2'b00};
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    case (cur_imm[1:0])
                        2'b00: tmp_word <= data[15:0];
                        2'b01: tmp_word <= data[23:8];
                        2'b10: tmp_word <= data[31:16];
                        2'b11: begin
                            tmp_word[7:0] <= data[31:24];
                            address <= MEM_BASE + {cur_imm[15:2], 2'b00} + 16'd4;
                            read_req <= 1;
                            byte_enable <= 4'b1111;
                        end
                        default: begin
                        end
                    endcase
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (cur_imm[1:0] == 2'b11) tmp_word[15:8] <= data[7:0];
                    SP <= SP - 16'd2;
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    write_data <= {2{tmp_word}};
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_req <= '1;
                end

                default: begin
                end
            endcase
        end

        // STORE
        6'b000100: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];

                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[15:0];
                    else tmp_address <= data[31:16];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    address <= MEM_BASE + {tmp_address[15:2], 2'b00};
                    write_req <= 1;
                    case (tmp_address[1:0])
                        2'b00: begin
                            write_data <= {2{tmp_word}};
                            byte_enable <= 4'b0011;
                        end

                        2'b10: begin
                            write_data <= {2{tmp_word}};
                            byte_enable <= 4'b1100;
                        end

                        2'b01: begin
                            write_data <= {4{tmp_word[7:0]}};
                            byte_enable <= 4'b0010;
                        end

                        2'b11: begin
                            write_data <= {4{tmp_word[7:0]}};
                            byte_enable <= 4'b1000;
                        end

                        default: begin
                        end
                    endcase
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    case (tmp_address[1:0])
                        2'b01: begin
                            address <= MEM_BASE + {tmp_address[15:2], 2'b00};
                            write_data <= {4{tmp_word[15:8]}};
                            byte_enable <= 4'b0100;
                            write_req <= 1;
                        end

                        2'b11: begin
                            address <= MEM_BASE + {tmp_address[15:2], 2'b00} + 16'd4;
                            write_data <= {4{tmp_word[15:8]}};
                            byte_enable <= 4'b0001;
                            write_req <= 1;
                        end

                        default: begin
                        end
                    endcase
                end

                default: begin
                end
            endcase
        end

        // STORE $imm
        6'b100001: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    tmp_word <= cur_imm;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[15:0];
                    else tmp_address <= data[31:16];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    address <= MEM_BASE + {tmp_address[15:2], 2'b00};
                    write_req <= 1;
                    case (tmp_address[1:0])
                        2'b00: begin
                            write_data <= {2{tmp_word}};
                            byte_enable <= 4'b0011;
                        end

                        2'b10: begin
                            write_data <= {2{tmp_word}};
                            byte_enable <= 4'b1100;
                        end

                        2'b01: begin
                            write_data <= {4{tmp_word[7:0]}};
                            byte_enable <= 4'b0010;
                        end

                        2'b11: begin
                            write_data <= {4{tmp_word[7:0]}};
                            byte_enable <= 4'b1000;
                        end

                        default: begin
                        end
                    endcase
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    case (tmp_address[1:0])
                        2'b01: begin
                            address <= MEM_BASE + {tmp_address[15:2], 2'b00};
                            write_data <= {4{tmp_word[15:8]}};
                            byte_enable <= 4'b0100;
                            write_req <= 1;
                        end

                        2'b11: begin
                            address <= MEM_BASE + {tmp_address[15:2], 2'b00} + 16'd4;
                            write_data <= {4{tmp_word[15:8]}};
                            byte_enable <= 4'b0001;
                            write_req <= 1;
                        end

                        default: begin
                        end
                    endcase
                end

                default: begin
                end
            endcase
        end

        // STORE %FR
        6'b000101: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[15:0];
                    else tmp_address <= data[31:16];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    address <= MEM_BASE + {tmp_address[15:2], 2'b00};
                    write_req <= 1;
                    case (tmp_address[1:0])
                        2'b00: begin
                            write_data <= {2{FR}};
                            byte_enable <= 4'b0011;
                        end

                        2'b10: begin
                            write_data <= {2{FR}};
                            byte_enable <= 4'b1100;
                        end

                        2'b01: begin
                            write_data <= {4{FR[7:0]}};
                            byte_enable <= 4'b0010;
                        end

                        2'b11: begin
                            write_data <= {4{FR[7:0]}};
                            byte_enable <= 4'b1000;
                        end

                        default: begin
                        end
                    endcase
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    case (tmp_address[1:0])
                        2'b01: begin
                            address <= MEM_BASE + {tmp_address[15:2], 2'b00};
                            write_data <= {4{FR[15:8]}};
                            byte_enable <= 4'b0100;
                            write_req <= 1;
                        end

                        2'b11: begin
                            address <= MEM_BASE + {tmp_address[15:2], 2'b00} + 16'd4;
                            write_data <= {4{FR[15:8]}};
                            byte_enable <= 4'b0001;
                            write_req <= 1;
                        end

                        default: begin
                        end
                    endcase
                end

                default: begin
                end
            endcase
        end

        // SWAP
        6'b000110: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    tmp_address <= SP + 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[31:16];
                    else tmp_word <= data[15:0];

                    address <= MEM_BASE + {tmp_address[15:2], 2'b00};
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (tmp_address[1]) begin
                        cur_imm <= data[31:16];
                        byte_enable <= 4'b1100;
                    end else begin
                        cur_imm <= data[15:0];
                        byte_enable <= 4'b0011;
                    end

                    write_data <= {2{tmp_word}};
                    address <= MEM_BASE + {tmp_address[15:2], 2'b00};
                    write_req <= 1;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    if (SP[1]) begin
                        byte_enable <= 4'b1100;
                    end else begin
                        byte_enable <= 4'b0011;
                    end

                    write_data <= {2{cur_imm}};
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                end

                default: begin
                end
            endcase
        end

        // DUP
        6'b000111: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP - 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;

                    write_data <= {2{tmp_word}};
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                end

                default: begin
                end
            endcase
        end

        // DUP2
        6'b001000: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP - 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{tmp_word}};
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    SP <= SP - 16'd2;
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{tmp_word}};
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                end

                default: begin
                end
            endcase
        end

        // MOV
        6'b100010: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    SP <= SP - 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;

                    write_data <= {2{cur_imm}};
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                end

                default: begin
                end
            endcase
        end

        // PUSH
        6'b001001: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];
                    TOS <= TOS + 16'd2;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (TOS[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{tmp_word}};
                    address <= MEM_BASE + {TOS[15:2], 2'b00};
                    write_req <= 1;
                end

                default: begin
                end
            endcase
        end

        // PUSH %FR
        6'b001010: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    TOS <= TOS + 16'd2;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (TOS[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{FR}};
                    address <= MEM_BASE + {TOS[15:2], 2'b00};
                    write_req <= 1;
                end

                default: begin
                end
            endcase
        end

        // POP
        6'b001100: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {TOS[15:2], 2'b00};
                    TOS <= TOS - 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (TOS[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];
                    SP <= SP - 16'd2;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{tmp_word}};
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                end

                default: begin
                end
            endcase
        end

        // POP %FR
        6'b001101: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {TOS[15:2], 2'b00};
                    TOS <= TOS - 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (TOS[1]) FR <= data[15:0];
                    else FR <= data[31:16];
                end

                default: begin
                end
            endcase
        end

        // ADD
        6'b001110: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];

                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[31:16];
                    else tmp_address <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    cur_imm <= tmp_word + tmp_address;
                    FR <= 16'd0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    FR[0] <= ((tmp_word + tmp_address) < tmp_word);
                    FR[1] <= (
                        (~cur_imm[15] & tmp_word[15] & tmp_address[15]) |
                        (cur_imm[15] & ~tmp_word[15] & ~tmp_address[15])
                    );
                    FR[2] <= cur_imm[15];
                    FR[3] <= cur_imm == 0;

                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{cur_imm}};
                end

                default: begin
                end
            endcase
        end

        // SUB
        6'b001111: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];

                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[31:16];
                    else tmp_address <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    cur_imm <= tmp_word - tmp_address;
                    FR <= 16'd0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    FR[0] <= ((tmp_word + tmp_address) < tmp_word);
                    FR[1] <= (
                        (~cur_imm[15] & tmp_word[15] & tmp_address[15]) |
                        (cur_imm[15] & ~tmp_word[15] & ~tmp_address[15])
                    );
                    FR[2] <= cur_imm[15];
                    FR[3] <= cur_imm == 0;

                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{cur_imm}};
                end

                default: begin
                end
            endcase
        end

        // MUL
        6'b010000: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];

                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[31:16];
                    else tmp_address <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    cur_imm <= tmp_word * tmp_address;
                    FR <= 16'd0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    FR[0] <= ((tmp_word + tmp_address) < tmp_word);
                    FR[1] <= (
                        (~cur_imm[15] & tmp_word[15] & tmp_address[15]) |
                        (cur_imm[15] & ~tmp_word[15] & ~tmp_address[15])
                    );
                    FR[2] <= tmp_word[15] ^ tmp_address[15];
                    FR[3] <= (tmp_word == 0) | (tmp_address == 0);

                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{cur_imm}};
                end

                default: begin
                end
            endcase
        end

        // DIV
        6'b010001: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];

                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[31:16];
                    else tmp_address <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    if (tmp_address == 0) cur_imm <= 0;
                    else cur_imm <= tmp_word / tmp_address;
                    FR <= 16'd0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    FR[0] <= ((tmp_word + tmp_address) < tmp_word);
                    FR[1] <= (
                        (~cur_imm[15] & tmp_word[15] & tmp_address[15]) |
                        (cur_imm[15] & ~tmp_word[15] & ~tmp_address[15])
                    );
                    FR[2] <= tmp_word[15] ^ tmp_address[15];
                    FR[3] <= (tmp_word == 0) | (tmp_address == 0);
                    FR[4] <= tmp_address == 0;

                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{cur_imm}};
                end

                default: begin
                end
            endcase
        end

        // AND
        6'b010010: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];

                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[31:16];
                    else tmp_address <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    if (tmp_address == 0) cur_imm <= 0;
                    else cur_imm <= tmp_word & tmp_address;
                    FR <= 16'd0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    FR[0] <= 0;
                    FR[2] <= tmp_word[15] ^ tmp_address[15];
                    FR[3] <= (tmp_word == 0) | (tmp_address == 0);

                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{cur_imm}};
                end

                default: begin
                end
            endcase
        end

        // OR
        6'b010011: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];

                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[31:16];
                    else tmp_address <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    if (tmp_address == 0) cur_imm <= 0;
                    else cur_imm <= tmp_word | tmp_address;
                    FR <= 16'd0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    FR[0] <= 0;
                    FR[2] <= tmp_word[15] ^ tmp_address[15];
                    FR[3] <= (tmp_word == 0) | (tmp_address == 0);

                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{cur_imm}};
                end

                default: begin
                end
            endcase
        end

        // XOR
        6'b010100: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];

                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[31:16];
                    else tmp_address <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    if (tmp_address == 0) cur_imm <= 0;
                    else cur_imm <= tmp_word ^ tmp_address;
                    FR <= 16'd0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    FR[0] <= 0;
                    FR[2] <= tmp_word[15] ^ tmp_address[15];
                    FR[3] <= (tmp_word == 0) | (tmp_address == 0);

                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{cur_imm}};
                end

                default: begin
                end
            endcase
        end

        // NOT
        6'b010101: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= ~data[31:16];
                    else tmp_word <= ~data[15:0];
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    FR[1] <= tmp_word == 0;
                    FR[3] <= tmp_word == 0;

                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{tmp_word}};
                end

                default: begin
                end
            endcase
        end

        // LSH
        6'b100011: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[31:16];
                    else tmp_word <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC: begin
                    tmp_address <= tmp_word << cur_imm;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    FR[1] <= {tmp_word >> (16 - cur_imm)} != 0;
                    FR[3] <= tmp_address == 0;

                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{tmp_address}};
                end

                default: begin
                end
            endcase
        end

        // RSH
        6'b100100: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[31:16];
                    else tmp_word <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC: begin
                    tmp_address <= tmp_word >> cur_imm;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    FR[1] <= {tmp_word << (16 - cur_imm)} != 0;
                    FR[3] <= tmp_address == 0;

                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{tmp_address}};
                end

                default: begin
                end
            endcase
        end

        // CALL $NUM
        6'b100101: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    TOS <= TOS + 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (TOS[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{PC}};
                    address <= MEM_BASE + {TOS[15:2], 2'b00};
                    write_req <= 1;
                end

                CPU_STATE_INSTR_EXEC: begin
                    PC <= PC + cur_imm;
                end

                default: begin
                end
            endcase
        end

        // CALL
        6'b010110: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    TOS <= TOS + 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (TOS[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{PC}};
                    address <= MEM_BASE + {TOS[15:2], 2'b00};
                    write_req <= 1;
                end

                CPU_STATE_INSTR_EXEC: begin
                    read_req <= '1;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                    SP <= SP - 16'd2;
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[15:0];
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    PC <= PC + tmp_word;
                end

                default: begin
                end
            endcase
        end

        // RET
        6'b010111: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {TOS[15:2], 2'b00};
                    TOS <= TOS - 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (TOS[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];
                end

                CPU_STATE_INSTR_EXEC: begin
                    PC <= tmp_word;
                end

                default: begin
                end
            endcase
        end

        // CMPE
        6'b011000: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (~SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];

                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[31:16];
                    else tmp_address <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    if (tmp_address == tmp_word) cur_imm <= 16'hFFFF;
                    else cur_imm <= 16'h0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{cur_imm}};
                end

                default: begin
                end
            endcase
        end

        // TODO: Fix this. Why does it not work anyways?
        // CMPE $IMM
        6'b100110: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[31:16];
                    else tmp_word <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    if (cur_imm == tmp_word) cur_imm <= 16'hFFFF;
                    else cur_imm <= 16'h0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{tmp_address}};
                end

                default: begin
                end
            endcase
        end

        // CMPB
        6'b011001: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];

                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (SP[1]) tmp_address <= data[31:16];
                    else tmp_address <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    if (tmp_address > tmp_word) cur_imm <= 16'hFFFF;
                    else cur_imm <= 16'h0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{cur_imm}};
                end

                default: begin
                end
            endcase
        end

        // CMPB $IMM
        6'b100111: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[31:16];
                    else tmp_word <= data[15:0];
                end

                CPU_STATE_INSTR_EXEC_1: begin
                    if (cur_imm > tmp_word) cur_imm <= 16'hFFFF;
                    else cur_imm <= 16'h0;
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    write_req <= 1;
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_data <= {2{tmp_address}};
                end

                default: begin
                end
            endcase
        end

        // JMP
        6'b011010: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    PC <= PC + tmp_word;
                end

                default: begin
                end
            endcase
        end

        // JMP $IMM
        6'b101000: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    PC <= PC + cur_imm;
                end

                default: begin
                end
            endcase
        end

        // JC
        6'b011011: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (tmp_word == 16'hFFFF) begin
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                        address <= MEM_BASE + {SP[15:2], 2'b00};
                        SP <= SP + 16'd2;
                        byte_enable <= 4'b1111;
                    end
                end

                CPU_STATE_INSTR_OPERAND_EXEC_1: begin
                    if (SP[1]) tmp_address <= data[15:0];
                    else tmp_address <= data[31:16];
                end

                CPU_STATE_INSTR_WRITEBACK: begin
                    if (tmp_word == 16'hFFFF) PC <= PC + address;
                end

                default: begin
                end
            endcase
        end

        // JC $IMM
        6'b101001: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    read_req <= 1;
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    SP <= SP + 16'd2;
                    byte_enable <= 4'b1111;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= data[31:16];
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (tmp_word == 16'hFFFF) PC <= PC + cur_imm;
                end

                default: begin
                end
            endcase
        end

        // IN $IMM
        6'b101010: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    uart_read_req <= 1;
                    SP <= SP - 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    tmp_word <= {8'b0, uart_data};
                end

                CPU_STATE_INSTR_EXEC: begin
                    write_data <= {2{tmp_word}};
                    if (SP[1]) byte_enable <= 4'b1100;
                    else byte_enable <= 4'b0011;
                    write_req <= 1;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                end

                default: begin
                end
            endcase
        end

        // OUT $IMM
        6'b101011: begin
            case (cur_cpu_state)
                CPU_STATE_INSTR_OPERAND_FETCH: begin
                    byte_enable <= 4'b1111;
                    address <= MEM_BASE + {SP[15:2], 2'b00};
                    read_req <= 1;
                    SP <= SP + 16'd2;
                end

                CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                    if (SP[1]) tmp_word <= data[15:0];
                    else tmp_word <= {data[31:16]};
                end

                CPU_STATE_INSTR_EXEC: begin
                    if (cur_imm == 0) begin
                        uart_write_req <= 1;
                        uart_wdata <= tmp_word[7:0];
                    end else GPIOS[cur_imm[5:0]] <= tmp_word[0];
                end

                default: begin
                end
            endcase
        end
    endcase
end


end
end
end

endmodule
